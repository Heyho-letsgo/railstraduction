<!DOCTYPE html>
<html lang="fr">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>0103</title>

		<!-- Bootstrap CSS -->
		<link href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">

		<!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
		<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
		<!--[if lt IE 9]>
			<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
			<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
		<![endif]-->
	</head>
	<body>
03 - Views et Controllers
A présent que nous avons généré un squelette d'application, il est temps de le modifier en ajoutant des fonctionnalités (features en anglais). La première fonctionnalité que nous voulons ajouter est une page qui listera une liste de film.Elle est par convention appelée page "index". 

La page "index"affichera l'URL http://localhost:3000/movies/

Pour faire en sorte que cela fonctionne, nous avons quatre taches à effectuer.

1 - Ajouter une route pour traiter les demandes d'accès au répertoire /movies

2 - Générer un contrôleur concernant les actions liées aux pages du répertoire /movies 

3 - Ajouter une action "index" qui prépare un tableau (array) de titres de film.

4 - Créer une page (view)(index.html.erb) à qui affichera dynamiquement une page HTML listant des titres de films.


Nous avancerons étape par étape en utilisant les messages d'erreur comme guide.

Objectif

1. Afficher une liste de titres de films

Nous commencerons par afficher une liste de titre de film en "dur" avant de passer à quelque chose de plus dynamique.

    1. Vérifions que nous avons l'application flix ouverte dans le terminal

rails s

Si l'application est déjà ouverte sur le port 3000, vous aurez un message "Adress already in use".

    2. Il est d'usage commun de laisser le serveur tourner dans une fenêtre du terminal et d'en ouvrir une seconde pour exécuter d'autres commandes. Soyez sur d'être dans la deuxième fenêtre et dans le répertoire flix.

    3. Maintenant, allez dans votre navigateur et tapez http://localhost:3000/movies. Vous devriez avoir le message d'erreur suivant

Routing Error 
No route matches [GET] "/movies"

Les messages d'erreur sont vos amis. Ils essayent de vous aider à comprendre les problèmes. Malheureusement, nous sommes habitué à faire rimé "message d'erreur" avec "mauvaise chose", et quand nous en voyons un, nous paniquons.

Voilà un petit secret...

Même les meilleurs programmeurs Rails ont des messages d'erreurs--souvent. Mais ils ne paniquent pas. A la place, les bons programmeurs lisent tranquillement les messages d'erreur. Et si vous prenez le temps de comprendre ce que Rails essaye de vous dire, après un certain temps vous reconnaîtrez (et réparerz) rapidement les erreurs communes.

Dans notre cas, voici ce qu'il se passe: Le navigateur web envoie une requête à l'URL http://localhost:3000/movies. 

http://localhost:3000 est l'adresse du serveur local que nous avons lancé et qui concerne l'application Rails. En lui rajoutant /movies, nous lui demandons d'aller jusqu'à ce répertoire (et c'est de là que vient l'erreur).

En effet, le routeur récupère la requête et essaye de trouver une route qui corresponde à "GET request for /movies". Mais nous n'avons pas encore dit au routeur que faire avec ce type de requête; c'est la raison de l'erreur.


    4. Pour dire au routeur comment gérer des requêtes, nous devons ouvrir le fichier config/routes.rb . Ce fichier ouvert, vous remarquez que de nombreuses ligne commentées  (précédées par une #) et informent sur les différentes possibilités de configurer ce fichier. 
Nous n'en avons pas besoins; aussi supprimons les afin de n'avoir plus que :

Flix::Application.routes.draw do 
end 

Nous n'avons plus q'un bloc Ruby vide auquel il faut ajouter une route.

    5. On veut que cette route dise: va chercher (get) dans le répertoire /movies le fichier nommé movies_controller.rb  et regarde si il y a une action (une méthode Ruby) qui s'appelle index.

Par convention cela s'écrit :

verb    "url"        =>    "name_of_controller#name_of_action"

et donc

get     "movies"     =>     "movies#index" 

que l'on insère dans

Flix::Application.routes.draw do 
Get     "movies"     =>     "movies#index"
end 

    6. Rafraîchissez votre navigateur et cette fois, vous avez un nouveau message d'erreur

Routing Error 
uninitialized constant MoviesController

Oh... non, encore un message d'erreur ! Super ! Vous ne paniquez pas. Vous lisez tranquillement ce qu'il dit. Il nous dit qu'il ne trouve pas le contrôleur Movies car il n'existe pas (unitialized).
Nous allons donc le créer.

It tells us that the route we added is trying to do what we told it to do. It's trying to send the request to a controller. We said the name of the controller was movies, but the router applied a naming convention and went looking for a Ruby class named MoviesController. We don't have a class with that name in our project, so the next step is to create it.

    7.  De retour dans le terminal et dans le répertoire flix nous allons générer une classe MoviesController en tapant:
rails generate controller movies 
    Par convention le nommage d'un controller DOIT être pluriel. Dans ce cas, c'est "movies"

    8. Cela génère une classe MoviesController vide dans le répertoire app/controllers/movies_controller.rb qui ressemble à :
class MoviesController < ApplicationController 
end

Bien que ce n'est pas important pour le moment, il est intéressant de remarquer que la classe hérite de la class ApplicationController.
ApplicationController est la classe parente de tout les contrôleurs et est situé dans app/controllers/application_controller.rb.
C'est grâce à cette relation d'héritage que la classe MoviesController sait agir comme un contrôleur.

    9. Rafraîchissez votre navigateur et cette fois vous avez encore une autre (différente) erreur.

Unknown action 
The action 'index' could not be found for MoviesController

    Ok, nous avançons. Cette fois le routeur a trouvé la classe et essaye d'appeler l'action index. C'est ce que dit la route, mais comme le dit intelligemment le message d'erreur, la classe MoviesController n'a pas de d'action (method) nommée index.

    10. Dans la classe MoviesController, définissez une action index vide. Rappelez-vous, une action est tout simplement une méthode Ruby accessible au public définie dans une classe de contrôleur.

class MoviesController < ApplicationController 
def index
end
end

    11. Rafraîchissez votre navigateur et... devinez quoi ? Vous avez encore un message d'erreur ! 

Template is missing 
Missing template movies/index ...

    On y est presque! Une fois encore le message d'erreur nous aide. Le routeur a avec succès envoyé la requête à l'action index de la classe MoviesController. L'action index se lance, mais il nous manque quelquechose. Nous devons retourner une liste de titres de films au navigateur. Pour faire cela, l'action doit rendre (render) un gabarit de vue (view template) qui à son tour génère du HTML.  Nous avons donc cette erreur car nous n'avons pas de de view template pour l'action index.
 
    Ehh... Attend! Notre action index est vide. Alors comment Rails sait i11l quelle vue il doit rendre ? La réponse courte est "convention sur configuration". Rails utilise une convention de nommage. Dans ce cas, du fait que le nom de l'action est index, Rails suppose qu'il doit rechercher un fichier appelé index.html.erb dans app/views/movies. Et le message d'erreur nous dit qu'il manque ce fichier :-)

    12. Créez un fichier nommé index.html.erb dans app/views/movies.
    À l'intérieur du nouveau fichier, ajoutez l'extrait de code HTML suivant

<h1>Movies</h1> 
<ul> 
<li>Iron Man</li>
<li>Superman</li>
<li>Spider-Man</li>
</ul>

    13. Sauvegardez votre fichier !
    
    14. Rafraîchissez votre navigateur, et cette fois vous verrez s'afficher une liste de titre de film...
    Excellent ! A présent, nous savons que notre requête traverse notre application: du routeur à l'action dans le controller, puis la vue et enfin retour au web.

2. Utiliser une variable d'instance 

Cela fonctionne, mais nous aimerions faire quelquechose de plus dynamique... La première chose à faire est d'affecter de vrais responsabilité à la vue et au controller.

Actuellement la vue a une liste de titre de film codé en dur. Nous aimerions rajouter ou retirer des films, et plus tard nous aimerions les extraire de la base de donnée.

Pour cela, la vue doit être concernée uniquement par la façon de savoir comment afficher les films. C'est le travail du controller de préparer les données afin que la vue les affiche.

Et la façon de passer des données à une vue se fait en réglant les variables d'instance.  

Une variable d'instance est une variable à laquelle à un temps T est affecté une valeur. Cela peut être un tableau (array), un chiffre, du texte, une image, une autre variable...

    1. Nous sommes concerné en ce moment par la view index et donc par l'action index du controller Movies (movies_contoller.rb).
        Nous allons donc affecter à cette variable un objet, en l’occurrence un tableau (array) qui contient des chaines de caractères (string) à savoir la liste des titres de films.
        Nous l'appellerons @movies

def index
@movies = ['Iron Man','Superman','Spiderman']    
end

    2. Pour faire en sorte que les films soit accessibles dans la vue, il faut ajouter ce bout de code (snippet) ERB (Embeded Ruby) dans la vue index.html.erb
<%= @movies%>
    
    3. Rafraîchissez votre navigateur, vous devriez voir s'afficher la liste des films sous format array (tableau).
 ['Iron Man','Superman','Spiderman']
    Cet affichage n'est pas très sympa pour l'utilisateur (not user friendly), mais on va voir ce que l'on peut faire...
3. Générer la liste dynamiquement

Enfin, nous voulons remplacer la liste codée en dur de titres de films dans le fichier index.html.erb en une liste générée dynamiquement qui reflète les titres dans la variable @movies.

Pour cela, nous allons utiliser un mélange de HTML et de code Ruby dans le fichier index.html.erb. Nous utiliserons Ruby pour parcourir (iterate) les chaines de caractères (string) de la variable @movies. Et pour chaque (each) titre de film, nous générerons une liste HTML d'article.

C'est là que le nom de la vue (view) est important.  Le nom de notre fichier view est index.html.erb. Il se décompose en trois parties:  index est le nom de l'action, html est le type de contenue que la vue va générer, et erb (Embedded Ruby) est le systeme de gabarit utilisé pour généré le contenu

Dans une application Rails, ERb (Embedded Ruby) est le système de gabarit par défaut. Il nous permet de mélanger du code Ruby avec du code HTML dans une page, puis quand la page doit être affichée, le code Embedded Ruby se lance et offre finalement une réponde générée dynamiquement.

Donc une vue Raills typique est un simple mélange de balises(tags) HTML et de balises(tags) ERb.

Les balises ERb sont de deux types:
<%= du code Ruby%> lance le code ruby, affiche le résultat dans la vue (le = est juste à coté du %) 
<% du code Ruby%> lance le code ruby, n'affiche pas le résultat dans la vue (le = n'est pas à coté du %). On peut y mettre des conditions ou autres que l'on ne souhaite pas afficher...
Chaque développeur Rails de la planète  oublie à un moment ou un autre de mettre le signe (=), et se demande pendant quelques minutes pourquoi son code ne s'affiche pas dans la vue... Cela vous arrivera aussi, vous êtes prévenu :)

    1. Dans le fichier index.html.erb, nous allons utiliser Ruby pour répéter (to iterate) une boucle (loop) pour chaque titre de film dans le tableau (array) @movies.

    Pour rappel, nous avons définie dans le fichier movies_controller.rb une action index (def index) avec une variable @movies

def index    
@movies = ['Iron Man','Superman','Spiderman']
end

    2. Dans le fichier index.html.erb supprimons ce qui a été écrit précédemment et remplaçons le par 

<ul>
<% @movies.each do |m| %>
<li><%= m %>
<% end %>
</ul>

    3. Nous avons séparé l'endroit d'ou provienne les données (movies_controller.rb) et l'endroit ou nous les affichons; la vue index.html.erb. Il suffit de rajouter un film dans le contriller pour qu'il apparaisse à l'affichage de la vue dans le navigateur.

    4. Rajoutons un film:
def index    
@movies = ['Iron Man','Superman','Spiderman', 'Batmans']
end
 

et affichage ...
Bonus Round

Afficher le fichier des connexions (log file)

Il est utile de savoir ce qu'il se passe en coulisse. Chaque fois que Rails génère une requête, il laisse une trace dans le fichier des connexions.

Afficher la fenêtre du terminal ou Rails server est lancé et rafraîchissez la page de la liste des films.
Vous devriez voir quelque chose comme ceci s'afficher dans la fenêtre du terminal.

Started GET "/movies" for 127.0.0.1 at 2014-04-19 10:32:19 +0200       -> C'est la requête
Processing by MoviesController#index as HTML                           -> Elle passe par le contrôleur et par l'action index 
Rendered movies/index.html.erb within layouts/application (0.1ms)      -> Elle est affiché dans la vue
Completed 200 OK in 9ms (Views: 7.4ms | ActiveRecord: 0.0ms)           -> C'est terminé


A chaque fois que la page est rafraîchie ce cycle de quesion/réponse se passe. Allez y et rafraîchissez plusieurs fois la page pour donner à Rails un peu de travail...

Toutes les requêtes sont enregistrées de façon permanente dans le fichier log/development.log En fait, ce que l'on voit dans le terminal est un affichage de ce que Rails ajoute dans le log file (fichier des connexions)  
		<!-- jQuery -->
		<script src="//code.jquery.com/jquery.js"></script>
		<!-- Bootstrap JavaScript -->
		<script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
	</body>
</html>
